#+TITLE: QMK Vim
#+OPTIONS: ^:nil

* Table of Contents :TOC_3:noexport:
- [[#about][About]]
- [[#features][Features]]
  - [[#core-features][Core Features]]
    - [[#motions][Motions]]
    - [[#actions][Actions]]
    - [[#normal-mode][Normal Mode]]
    - [[#insert-mode][Insert Mode]]
    - [[#visual-mode][Visual Mode]]
    - [[#visual-line-mode][Visual Line Mode]]
- [[#configuration][Configuration]]
  - [[#setup][Setup]]
  - [[#extra-feature-macros][Extra Feature Macros]]
  - [[#dot-repeat][Dot Repeat]]

* About
This is project aims to emulate as much of vim as possible in QMK userspace. The idea is to use clever combinations of shift, home, end, and control + arrow keys to emulate vim's modal editing and motions.

The other goal is to make it relatively plug and play in user keymaps, while still providing customization options.

* Features
** Core Features
The core features are in in the tables below and takes up roughly 5% of at Atmega32u4.
*** Motions
Motions are available in [[#normal-mode][normal]] and [[#visual-mode][visual mode]], and can be composed with [[#actions][actions]]. Note that in the table below the mods shown are for Linux/Windows, however if =VIM_FOR_MAC= is defined then these should change to =LOPT=.
| Vim Binding | Action       | Notes                                                                             |
|-------------+--------------+-----------------------------------------------------------------------------------|
| h           | LEFT         |                                                                                   |
| j           | DOWN         |                                                                                   |
| k           | UP           |                                                                                   |
| l           | RIGHT        |                                                                                   |
| w           | LCTL + RIGHT | This may act more like an =e= command depending on the text environment             |
| e           | LCTL + RIGHT | This may act more like an =w= command depending on the text environment             |
| b           | LCTL + LEFT  |                                                                                   |
| 0           | HOME         | In some text environments this goes to the true start, or the first piece of text |
| $           | END          |                                                                                   |

*** Actions
Change, delete, and yank actions are all supported and can be combined with [[#motions][motions]] and text objects in normal mode as you would expect. For example =cw= will change until the next word (or end of word depending on your text environment). Note that by default the =d= action will copy the deleted text to the clipboard.

In visual mode each action can be accessed with =c=, =d=, and =y= respectively and they will act on the currently selected visual area.

Normal mode also supports these commands:
| Vim Binding | Action                | Notes                                              |
|-------------+-----------------------+----------------------------------------------------|
| cc          | Change line           | This doesn't copy the old line to clipboard        |
| C           | Change to end of line | This doesn't copy the changed content to clipboard |
| dd          | Delete line           | This copies the deleted line to clipboard          |
| D           | Delete to end of line | This copies the deleted text to clipboard          |
| yy          | Yank line             |                                                    |
| Y           | Yank to end of line   |                                                    |

**** Paste Action
The =paste_action()= handles pasting, which is simple for non lines, but most of the time, I'm pasting lines so this function attempts to consistently handle pasting lines. Yanks and deletes of lines are tracked through the =yanked_line= global, the paste action then pastes accordingly. For copying and pasting lines the line(s) the selection is made from the very start of the line below, up to start of the first line. See the [[#visual-line-mode][visual line mode]] section for more info on how lines are selected. There is also an optional =paste_before_action()=, enabled with the =VIM_PASTE_BEFORE= macro.

*** Normal Mode
This below tables lists all of the commands not covered by the [[#motions][motions]] and [[#actions][actions]] sections . Note that in the table below the mods shown are for Linux/Windows,
however if =VIM_FOR_MAC= is defined then these should change to =LCMD=.
| Vim Binding | Action                                          | Notes                                           |
|-------------+-------------------------------------------------+-------------------------------------------------|
| i           | [[#insert-mode][insert_mode()]]                 |                                                 |
| I           | HOME, [[#insert-mode][insert_mode()]]           |                                                 |
| a           | RIGHT, [[#insert-mode][insert_mode()]]          |                                                 |
| A           | END, [[#insert-mode][insert_mode()]]            |                                                 |
| o           | END, ENTER, [[#insert-mode][insert_mode()]]     |                                                 |
| O           | HOME, ENTER, UP [[#insert-mode][insert_mode()]] |                                                 |
| v           | [[#visual-mode][visual_mode()]]                 |                                                 |
| V           | [[#visual-line-mode][visual_line_mode()]]       |                                                 |
| p           | [[#paste-action][paste_action()]]               |                                                 |
| u           | LCTL + z                                        | This works /most/ places                        |
| CTRL + r    | LCTL + y                                        | This may or may not work everywhere             |
| x           | DELETE                                          | This is currently only supported in normal mode |

Note that all keycodes chorded with CTRL, GUI, or ALT, that aren't bound to anything are let through. In other words, you can still alt tab and use shortcuts for whatever editor you're in.

*** Insert Mode
Insert mode is rather straight forward, all keystrokes are passed through as normal with the exception of escape, which brings you back to [[#normal-mode][normal mode]].

*** Visual Mode
Visual mode behaves largely as one would expect, all [[#motions][motions]] and [[#actions][actions]] are supported. Escape of course returns you to [[#normal-mode][normal mode]].
Note that hitting escape may move your cursor unexpectedly, especially if you don't have =BETTER_VISUAL_MODE= enabled.
This is because there isn't a good way to just deselect text in "standard" editing, the best way is to move the text cursor with the arrow keys.
The trouble for us is choosing which way to move, by default we always move right.
However, with =BETTER_VISUAL_MODE= enabled the first direction moved in visual mode is recorded so that we can move the cursor to either the left or right or the selection as required.
Of course this approach breaks down if you double back on the cursor, but I find I don't do that all that often.

*** Visual Line Mode
Visual line modes is very similar to [[#visual-mode][visual mode]] as you would expect however only the ~j~ and ~k~ motions are supported and of course the entire line is selected.
However, there is no perfect way (that I know of) to select lines the way vim does easily. The way I used do it before I used vim, was to get myself to the start of the line then hit shift and up or down.
Going down works almost as you'd expect in vim, but you'll always be a line behind since it doesn't highlight the line the cursor is currently on.
Going up on the other hand will select the line the cursor is on, but it will always be missing the first line.
So neither solution quite works on it's own, =BETTER_VISUAL_MODE= does mostly fix these issues, but at the price of a larger compile size, hence why it's not on by default.

A note on the default implementation, since most programming environments make the home key go to the start of the indent or the actual start of the line dynamically, consistently getting to the start of a line isn't as easy as hitting home.
The most consistent way I've found is to hit end on the line above, and then right arrow your way to the start of the next line.
This works as long as there is no line wrapping, so in the default implementation, entering visual line mode sends ~KC_END~, ~KC_RIGHT~, ~LSFT(KC_UP)~.
Not only is this quite consistent, it also immediately highlights the current line just as you would expect.
The only downside with the default implementation is that if you then try to go down that first line will be deselected, so you have to start your visual selection a line above when moving downwards.
Of course =BETTER_VISUAL_MODE= fixes this as long as you don't double back on the cursor.

* Configuration
** Setup
+ First add the repo as a submodule to your keymap.
  #+begin_src bash
git submodule add https://github.com/andrewjrae/qmk-vim.git
  #+end_src

+ Next, you need source the files in the make file, the easy way to do this is to just add this line to your ~rules.mk~ file.
  #+begin_src make
include $(KEYBOARD_PATH_2)/keymaps/$(KEYMAP)/qmk-vim/rules.mk
  #+end_src
  If this doesn't work, you can either try changing the number in the =KEYBOARD_PATH_2= variable (values 1-5), or simply copy the contents from [[file:rules.mk][qmk-vim/rules.mk]].

+ Now add the header file so you can add =process_vim_mode()= to your =process_record_user()=, it can either go at the top or the bottom, it depends on how you want it to interact with your keycodes.

  If you process at the beginning it will look something like this, make sure that you return false when =process_vim_mode()= returns false.
  #+begin_src C
#include "qmk-vim/src/vim.h"

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    // Process case modes
    if (!process_vim_mode(keycode, record)) {
        return false;
    }
    ...
  #+end_src

+ The last step is to add a way to enter into vim mode. There are many ways to do this, personally I use leader sequences, but using combos or just a macro on a layer are all viable ways to do this.
  The important part here is ensure that you also have a way to get out of vim mode, since by default there is no way out.
  Enabling =VIM_COLON_CMDS= will allow you to also use ~:q~ or ~:wq~ in order to get out of vim, but in general I would recommend using the =toggle_vim_mode()= function.

  As a simple example, here is the setup for a simple custom keycode macro:
  #+begin_src C
enum custom_keycodes {
    TOG_VIM = SAFE_RANGE,
};

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    // Process case modes
    if (!process_vim_mode(keycode, record)) {
        return false;
    }

    // Regular user keycode case statement
    switch (keycode) {
        case CAPSWORD:
            if (record->event.pressed) {
                toggle_vim_mode();
            }
            return false;
        default:
            return true;
    }
}
  #+end_src

** Extra Feature Macros
| Macro                 | Features Enabled/Disabled                                                                                              | Bytes Used (avr-gcc 8.3.0) |
|-----------------------+------------------------------------------------------------------------------------------------------------------------+----------------------------|
| =NO_VISUAL_MODE=      | Disables the normal visual mode.                                                                                       |                            |
| =NO_VISUAL_LINE_MODE= | Disables the normal visual line mode.                                                                                  |                            |
| =BETTER_VISUAL_MODE=  | Makes the visual modes much more vim like, see [[#visual-line-mode][visual_line_mode()]] for details.                  |                            |
| =VIM_I_TEXT_OBJECTS=  | Adds the ~i~ text objects, which adds the ~iw~ and ~ig~ text objects, see [[#text-objects][text objects]] for details. |                            |
| =VIM_A_TEXT_OBJECTS=  | Adds the ~a~ text objects, which adds the ~aw~ and ~ag~ text objects.                                                  |                            |
| =VIM_G_MOTIONS=       | Adds ~gg~ and ~G~ motions, which only work in some programs.                                                           |                            |
| =VIM_COLON_CMDS=      | Adds the colon command state, but only the ~w~ and ~q~ commands are supported (can be in combination).                 |                            |
| =VIM_PASTE_BEFORE=    | Adds the ~P~ command.                                                                                                  |                            |
| =VIM_DOT_REPEAT=      | Adds the ~.~ command, allowing you to repeat actions, see [[#dot-repeat][dot repeat]] for details.                     |                            |

** Dot Repeat
The dot repeat feature can be enabled with the =VIM_DOT_REPEAT= macro. This lets the user hit the ~.~ key in normal mode to repeat the last normal mode command.
For example, typing ~ciw~, ~hello!~, will replace the underlying word with ~hello!~, now going over another word hitting ~.~ will repeat the action, just like vim does.
The way this works is that once an action starts, like ~c~ or ~D~, or even ~A~ all keycodes are recorded until we return to the normal mode state.
Once you hit ~.~ it goes through the recorded keys until it hits normal mode again.
The default size of the recorded keys buffer is =64=, but can be modified with the =VIM_REPEAT_BUF_SIZE= macro.
